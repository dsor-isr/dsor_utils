{"config":{"indexing":"full","lang":["en","pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;"},"docs":[{"location":"","text":"","title":"Introduction"},{"location":"api/markdown/dsor_utils/Classes/","text":"Classes class CircularDelay A class that functions as a sample buffer. class const_iterator class const_reverse_iterator class iterator class reverse_iterator namespace DSOR struct VehicleState State class - used to save the state of a vehicle (using SNAME convention) class Differentiator Class for the differentiator. class DigitalFilter Abstract base class for digital moving filters. class HighPassFilter Class for high pass filter using bilinear transform. class HighPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. class LowPassFilter Class for a low pass filter. class LowPassFilter2 Class for a 2nd order low pass filter. class LowPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. class LowPassFilter3DiffApprox Class for third order high pass filter. This is designed using the approximated differtial approuch where s=(Z-1)/(Z*T). class LowPassFilter3MatchedZ Class for third order low pass filter. This is designed using the matched Z transform. class MovingAvarageFilter class RateLimiter namespace tps Updated on 2023-05-26 at 16:18:58 +0000","title":"Classes"},{"location":"api/markdown/dsor_utils/Classes/#classes","text":"class CircularDelay A class that functions as a sample buffer. class const_iterator class const_reverse_iterator class iterator class reverse_iterator namespace DSOR struct VehicleState State class - used to save the state of a vehicle (using SNAME convention) class Differentiator Class for the differentiator. class DigitalFilter Abstract base class for digital moving filters. class HighPassFilter Class for high pass filter using bilinear transform. class HighPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. class LowPassFilter Class for a low pass filter. class LowPassFilter2 Class for a 2nd order low pass filter. class LowPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. class LowPassFilter3DiffApprox Class for third order high pass filter. This is designed using the approximated differtial approuch where s=(Z-1)/(Z*T). class LowPassFilter3MatchedZ Class for third order low pass filter. This is designed using the matched Z transform. class MovingAvarageFilter class RateLimiter namespace tps Updated on 2023-05-26 at 16:18:58 +0000","title":"Classes"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/","text":"CircularDelay A class that functions as a sample buffer. More... #include <circular_buffer.hpp> Public Classes Name class const_iterator class const_reverse_iterator class iterator class reverse_iterator Public Functions Name CircularDelay () Constructor that initializes that buffer and its set index. type push (type input) With this function you can insert a new sample into the buffer. type get (size_t delay) With this function you can retrieve a sample from the past. iterator end () iterator begin () reverse_iterator rend () reverse_iterator rbegin () Detailed Description template <typename type , size_t size> class CircularDelay; A class that functions as a sample buffer. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Copyright : GPL V3 Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/CircularDelay/tree/master Brief: Circular delay software library. Here data can be stored and retrieved is a LiFo manner. License: GNU Copyright (C) 2018 Jimmy van den Berg This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/ . You can use this to insert samples and use the get function to get a sample from the past. Public Functions Documentation function CircularDelay CircularDelay() Constructor that initializes that buffer and its set index. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. function push type push( type input ) With this function you can insert a new sample into the buffer. Parameters : input Sample to push into. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Return : Value that has been pushed. function get type get( size_t delay ) With this function you can retrieve a sample from the past. Parameters : delay How many samples you ago you want to get. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Return : The sample of delay ago. Maximum delay is the size of the CircularDelay - 1. function end inline iterator end() function begin inline iterator begin() function rend inline reverse_iterator rend() function rbegin inline reverse_iterator rbegin() Updated on 2023-05-26 at 16:18:58 +0000","title":"CircularDelay"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/#circulardelay","text":"A class that functions as a sample buffer. More... #include <circular_buffer.hpp>","title":"CircularDelay"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/#public-classes","text":"Name class const_iterator class const_reverse_iterator class iterator class reverse_iterator","title":"Public Classes"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/#public-functions","text":"Name CircularDelay () Constructor that initializes that buffer and its set index. type push (type input) With this function you can insert a new sample into the buffer. type get (size_t delay) With this function you can retrieve a sample from the past. iterator end () iterator begin () reverse_iterator rend () reverse_iterator rbegin ()","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/#detailed-description","text":"template <typename type , size_t size> class CircularDelay; A class that functions as a sample buffer. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Copyright : GPL V3 Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/CircularDelay/tree/master Brief: Circular delay software library. Here data can be stored and retrieved is a LiFo manner. License: GNU Copyright (C) 2018 Jimmy van den Berg This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/ . You can use this to insert samples and use the get function to get a sample from the past.","title":"Detailed Description"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/#function-circulardelay","text":"CircularDelay() Constructor that initializes that buffer and its set index. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is.","title":"function CircularDelay"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/#function-push","text":"type push( type input ) With this function you can insert a new sample into the buffer. Parameters : input Sample to push into. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Return : Value that has been pushed.","title":"function push"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/#function-get","text":"type get( size_t delay ) With this function you can retrieve a sample from the past. Parameters : delay How many samples you ago you want to get. Template Parameters : type Type of sample that needs to be stored. size Size of how big the history buffer is. Return : The sample of delay ago. Maximum delay is the size of the CircularDelay - 1.","title":"function get"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/#function-end","text":"inline iterator end()","title":"function end"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/#function-begin","text":"inline iterator begin()","title":"function begin"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/#function-rend","text":"inline reverse_iterator rend()","title":"function rend"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay/#function-rbegin","text":"inline reverse_iterator rbegin() Updated on 2023-05-26 at 16:18:58 +0000","title":"function rbegin"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/","text":"CircularDelay::const_iterator Public Types Name typedef const_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type Public Functions Name const_iterator (const CircularDelay < type, size >:: const_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) const type & operator* () const type * operator-> () const type & operator[] (unsigned int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs) Friends Name class CircularDelay Public Types Documentation typedef self_type typedef const_iterator CircularDelay< type, size >::const_iterator::self_type; typedef iterator_category typedef std::bidirectional_iterator_tag CircularDelay< type, size >::const_iterator::iterator_category; typedef difference_type typedef int CircularDelay< type, size >::const_iterator::difference_type; Public Functions Documentation function const_iterator inline const_iterator( const CircularDelay< type, size >::const_iterator & it ) function operator++ inline self_type operator++() function operator++ inline self_type operator++( int ) function operator-- inline self_type operator--() function operator-- inline self_type operator--( int ) function operator* inline const type & operator*() function operator-> inline const type * operator->() function operator[] inline const type & operator[]( unsigned int index ) function operator== inline bool operator==( const self_type & rhs ) function operator!= inline bool operator!=( const self_type & rhs ) Friends friend CircularDelay friend class CircularDelay; Updated on 2023-05-26 at 16:18:58 +0000","title":"CircularDelay::const_iterator"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#circulardelayconst_iterator","text":"","title":"CircularDelay::const_iterator"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#public-types","text":"Name typedef const_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type","title":"Public Types"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#public-functions","text":"Name const_iterator (const CircularDelay < type, size >:: const_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) const type & operator* () const type * operator-> () const type & operator[] (unsigned int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs)","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#friends","text":"Name class CircularDelay","title":"Friends"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#typedef-self_type","text":"typedef const_iterator CircularDelay< type, size >::const_iterator::self_type;","title":"typedef self_type"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#typedef-iterator_category","text":"typedef std::bidirectional_iterator_tag CircularDelay< type, size >::const_iterator::iterator_category;","title":"typedef iterator_category"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#typedef-difference_type","text":"typedef int CircularDelay< type, size >::const_iterator::difference_type;","title":"typedef difference_type"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-const_iterator","text":"inline const_iterator( const CircularDelay< type, size >::const_iterator & it )","title":"function const_iterator"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator","text":"inline self_type operator++()","title":"function operator++"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_1","text":"inline self_type operator++( int )","title":"function operator++"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator-","text":"inline self_type operator--()","title":"function operator--"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator-_1","text":"inline self_type operator--( int )","title":"function operator--"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_2","text":"inline const type & operator*()","title":"function operator*"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator-_2","text":"inline const type * operator->()","title":"function operator-&gt;"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_3","text":"inline const type & operator[]( unsigned int index )","title":"function operator[]"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_4","text":"inline bool operator==( const self_type & rhs )","title":"function operator=="},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#function-operator_5","text":"inline bool operator!=( const self_type & rhs )","title":"function operator!="},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#friends_1","text":"","title":"Friends"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__iterator/#friend-circulardelay","text":"friend class CircularDelay; Updated on 2023-05-26 at 16:18:58 +0000","title":"friend CircularDelay"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/","text":"CircularDelay::const_reverse_iterator Public Types Name typedef const_reverse_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type Public Functions Name const_reverse_iterator (const CircularDelay < type, size >:: const_reverse_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) const type & operator* () const type * operator-> () const type & operator[] (int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs) Friends Name class CircularDelay Public Types Documentation typedef self_type typedef const_reverse_iterator CircularDelay< type, size >::const_reverse_iterator::self_type; typedef iterator_category typedef std::bidirectional_iterator_tag CircularDelay< type, size >::const_reverse_iterator::iterator_category; typedef difference_type typedef int CircularDelay< type, size >::const_reverse_iterator::difference_type; Public Functions Documentation function const_reverse_iterator inline const_reverse_iterator( const CircularDelay< type, size >::const_reverse_iterator & it ) function operator++ inline self_type operator++() function operator++ inline self_type operator++( int ) function operator-- inline self_type operator--() function operator-- inline self_type operator--( int ) function operator* inline const type & operator*() function operator-> inline const type * operator->() function operator[] inline const type & operator[]( int index ) function operator== inline bool operator==( const self_type & rhs ) function operator!= inline bool operator!=( const self_type & rhs ) Friends friend CircularDelay friend class CircularDelay; Updated on 2023-05-26 at 16:18:58 +0000","title":"CircularDelay::const_reverse_iterator"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#circulardelayconst_reverse_iterator","text":"","title":"CircularDelay::const_reverse_iterator"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#public-types","text":"Name typedef const_reverse_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type","title":"Public Types"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#public-functions","text":"Name const_reverse_iterator (const CircularDelay < type, size >:: const_reverse_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) const type & operator* () const type * operator-> () const type & operator[] (int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs)","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#friends","text":"Name class CircularDelay","title":"Friends"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#typedef-self_type","text":"typedef const_reverse_iterator CircularDelay< type, size >::const_reverse_iterator::self_type;","title":"typedef self_type"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#typedef-iterator_category","text":"typedef std::bidirectional_iterator_tag CircularDelay< type, size >::const_reverse_iterator::iterator_category;","title":"typedef iterator_category"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#typedef-difference_type","text":"typedef int CircularDelay< type, size >::const_reverse_iterator::difference_type;","title":"typedef difference_type"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-const_reverse_iterator","text":"inline const_reverse_iterator( const CircularDelay< type, size >::const_reverse_iterator & it )","title":"function const_reverse_iterator"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator","text":"inline self_type operator++()","title":"function operator++"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_1","text":"inline self_type operator++( int )","title":"function operator++"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator-","text":"inline self_type operator--()","title":"function operator--"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator-_1","text":"inline self_type operator--( int )","title":"function operator--"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_2","text":"inline const type & operator*()","title":"function operator*"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator-_2","text":"inline const type * operator->()","title":"function operator-&gt;"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_3","text":"inline const type & operator[]( int index )","title":"function operator[]"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_4","text":"inline bool operator==( const self_type & rhs )","title":"function operator=="},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#function-operator_5","text":"inline bool operator!=( const self_type & rhs )","title":"function operator!="},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#friends_1","text":"","title":"Friends"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1const__reverse__iterator/#friend-circulardelay","text":"friend class CircularDelay; Updated on 2023-05-26 at 16:18:58 +0000","title":"friend CircularDelay"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/","text":"CircularDelay::iterator Public Types Name typedef iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type Public Functions Name iterator (const CircularDelay < type, size >:: iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) type & operator* () type * operator-> () type & operator[] (unsigned int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs) Friends Name class CircularDelay Public Types Documentation typedef self_type typedef iterator CircularDelay< type, size >::iterator::self_type; typedef iterator_category typedef std::bidirectional_iterator_tag CircularDelay< type, size >::iterator::iterator_category; typedef difference_type typedef int CircularDelay< type, size >::iterator::difference_type; Public Functions Documentation function iterator inline iterator( const CircularDelay< type, size >::iterator & it ) function operator++ inline self_type operator++() function operator++ inline self_type operator++( int ) function operator-- inline self_type operator--() function operator-- inline self_type operator--( int ) function operator* inline type & operator*() function operator-> inline type * operator->() function operator[] inline type & operator[]( unsigned int index ) function operator== inline bool operator==( const self_type & rhs ) function operator!= inline bool operator!=( const self_type & rhs ) Friends friend CircularDelay friend class CircularDelay; Updated on 2023-05-26 at 16:18:58 +0000","title":"CircularDelay::iterator"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#circulardelayiterator","text":"","title":"CircularDelay::iterator"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#public-types","text":"Name typedef iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type","title":"Public Types"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#public-functions","text":"Name iterator (const CircularDelay < type, size >:: iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) type & operator* () type * operator-> () type & operator[] (unsigned int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs)","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#friends","text":"Name class CircularDelay","title":"Friends"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#typedef-self_type","text":"typedef iterator CircularDelay< type, size >::iterator::self_type;","title":"typedef self_type"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#typedef-iterator_category","text":"typedef std::bidirectional_iterator_tag CircularDelay< type, size >::iterator::iterator_category;","title":"typedef iterator_category"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#typedef-difference_type","text":"typedef int CircularDelay< type, size >::iterator::difference_type;","title":"typedef difference_type"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-iterator","text":"inline iterator( const CircularDelay< type, size >::iterator & it )","title":"function iterator"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator","text":"inline self_type operator++()","title":"function operator++"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_1","text":"inline self_type operator++( int )","title":"function operator++"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator-","text":"inline self_type operator--()","title":"function operator--"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator-_1","text":"inline self_type operator--( int )","title":"function operator--"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_2","text":"inline type & operator*()","title":"function operator*"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator-_2","text":"inline type * operator->()","title":"function operator-&gt;"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_3","text":"inline type & operator[]( unsigned int index )","title":"function operator[]"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_4","text":"inline bool operator==( const self_type & rhs )","title":"function operator=="},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#function-operator_5","text":"inline bool operator!=( const self_type & rhs )","title":"function operator!="},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#friends_1","text":"","title":"Friends"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1iterator/#friend-circulardelay","text":"friend class CircularDelay; Updated on 2023-05-26 at 16:18:58 +0000","title":"friend CircularDelay"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/","text":"CircularDelay::reverse_iterator Public Types Name typedef reverse_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type Public Functions Name reverse_iterator (const CircularDelay < type, size >:: reverse_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) type & operator* () type * operator-> () type & operator[] (int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs) Friends Name class CircularDelay Public Types Documentation typedef self_type typedef reverse_iterator CircularDelay< type, size >::reverse_iterator::self_type; typedef iterator_category typedef std::bidirectional_iterator_tag CircularDelay< type, size >::reverse_iterator::iterator_category; typedef difference_type typedef int CircularDelay< type, size >::reverse_iterator::difference_type; Public Functions Documentation function reverse_iterator inline reverse_iterator( const CircularDelay< type, size >::reverse_iterator & it ) function operator++ inline self_type operator++() function operator++ inline self_type operator++( int ) function operator-- inline self_type operator--() function operator-- inline self_type operator--( int ) function operator* inline type & operator*() function operator-> inline type * operator->() function operator[] inline type & operator[]( int index ) function operator== inline bool operator==( const self_type & rhs ) function operator!= inline bool operator!=( const self_type & rhs ) Friends friend CircularDelay friend class CircularDelay; Updated on 2023-05-26 at 16:18:58 +0000","title":"CircularDelay::reverse_iterator"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#circulardelayreverse_iterator","text":"","title":"CircularDelay::reverse_iterator"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#public-types","text":"Name typedef reverse_iterator self_type typedef std::bidirectional_iterator_tag iterator_category typedef int difference_type","title":"Public Types"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#public-functions","text":"Name reverse_iterator (const CircularDelay < type, size >:: reverse_iterator & it) self_type operator++ () self_type operator++ (int ) self_type operator-- () self_type operator-- (int ) type & operator* () type * operator-> () type & operator[] (int index) bool operator== (const self_type & rhs) bool operator!= (const self_type & rhs)","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#friends","text":"Name class CircularDelay","title":"Friends"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#typedef-self_type","text":"typedef reverse_iterator CircularDelay< type, size >::reverse_iterator::self_type;","title":"typedef self_type"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#typedef-iterator_category","text":"typedef std::bidirectional_iterator_tag CircularDelay< type, size >::reverse_iterator::iterator_category;","title":"typedef iterator_category"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#typedef-difference_type","text":"typedef int CircularDelay< type, size >::reverse_iterator::difference_type;","title":"typedef difference_type"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-reverse_iterator","text":"inline reverse_iterator( const CircularDelay< type, size >::reverse_iterator & it )","title":"function reverse_iterator"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator","text":"inline self_type operator++()","title":"function operator++"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_1","text":"inline self_type operator++( int )","title":"function operator++"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator-","text":"inline self_type operator--()","title":"function operator--"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator-_1","text":"inline self_type operator--( int )","title":"function operator--"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_2","text":"inline type & operator*()","title":"function operator*"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator-_2","text":"inline type * operator->()","title":"function operator-&gt;"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_3","text":"inline type & operator[]( int index )","title":"function operator[]"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_4","text":"inline bool operator==( const self_type & rhs )","title":"function operator=="},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#function-operator_5","text":"inline bool operator!=( const self_type & rhs )","title":"function operator!="},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#friends_1","text":"","title":"Friends"},{"location":"api/markdown/dsor_utils/Classes/classCircularDelay_1_1reverse__iterator/#friend-circulardelay","text":"friend class CircularDelay; Updated on 2023-05-26 at 16:18:58 +0000","title":"friend CircularDelay"},{"location":"api/markdown/dsor_utils/Classes/classDifferentiator/","text":"Differentiator Class for the differentiator. More... #include <differentiator.hpp> Inherits from DigitalFilter< T > Public Functions Name Differentiator (T sampleTime) Constructor to set sample time and the tau constant. virtual T update (T input) Update function to push new value into the differentiator. virtual T getOutput () Gets the output. Detailed Description template <typename T > class Differentiator; Class for the differentiator. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Class for a differentiator, inherited from the DigitalFilter class of moving filters. A differentiator is a filter that is designed such that the output is approximately directly proportionalto the rate of change (the time derivative) of the input. Public Functions Documentation function Differentiator inline Differentiator( T sampleTime ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter function update inline virtual T update( T input ) Update function to push new value into the differentiator. Parameters : input The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual T getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2023-05-26 at 16:18:58 +0000","title":"Differentiator"},{"location":"api/markdown/dsor_utils/Classes/classDifferentiator/#differentiator","text":"Class for the differentiator. More... #include <differentiator.hpp> Inherits from DigitalFilter< T >","title":"Differentiator"},{"location":"api/markdown/dsor_utils/Classes/classDifferentiator/#public-functions","text":"Name Differentiator (T sampleTime) Constructor to set sample time and the tau constant. virtual T update (T input) Update function to push new value into the differentiator. virtual T getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classDifferentiator/#detailed-description","text":"template <typename T > class Differentiator; Class for the differentiator. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Class for a differentiator, inherited from the DigitalFilter class of moving filters. A differentiator is a filter that is designed such that the output is approximately directly proportionalto the rate of change (the time derivative) of the input.","title":"Detailed Description"},{"location":"api/markdown/dsor_utils/Classes/classDifferentiator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classDifferentiator/#function-differentiator","text":"inline Differentiator( T sampleTime ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter","title":"function Differentiator"},{"location":"api/markdown/dsor_utils/Classes/classDifferentiator/#function-update","text":"inline virtual T update( T input ) Update function to push new value into the differentiator. Parameters : input The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/dsor_utils/Classes/classDifferentiator/#function-getoutput","text":"inline virtual T getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2023-05-26 at 16:18:58 +0000","title":"function getOutput"},{"location":"api/markdown/dsor_utils/Classes/classDigitalFilter/","text":"DigitalFilter Abstract base class for digital moving filters. More... #include <digital_filter.hpp> Public Functions Name virtual Type update (Type newValue) =0 virtual Type getOutput () =0 Detailed Description template <typename Type > class DigitalFilter; Abstract base class for digital moving filters. Template Parameters : Type Floating point type used. Public Functions Documentation function update virtual Type update( Type newValue ) =0 Reimplemented by : HighPassFilter::update , LowPassFilter::update , LowPassFilter2::update , HighPassFilter3::update , LowPassFilter3::update , LowPassFilter3MatchedZ::update , LowPassFilter3DiffApprox::update , Differentiator::update function getOutput virtual Type getOutput() =0 Reimplemented by : Differentiator::getOutput , LowPassFilter::getOutput , HighPassFilter::getOutput , LowPassFilter2::getOutput , HighPassFilter3::getOutput , LowPassFilter3::getOutput , LowPassFilter3MatchedZ::getOutput , LowPassFilter3DiffApprox::getOutput Updated on 2023-05-26 at 16:18:58 +0000","title":"DigitalFilter"},{"location":"api/markdown/dsor_utils/Classes/classDigitalFilter/#digitalfilter","text":"Abstract base class for digital moving filters. More... #include <digital_filter.hpp>","title":"DigitalFilter"},{"location":"api/markdown/dsor_utils/Classes/classDigitalFilter/#public-functions","text":"Name virtual Type update (Type newValue) =0 virtual Type getOutput () =0","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classDigitalFilter/#detailed-description","text":"template <typename Type > class DigitalFilter; Abstract base class for digital moving filters. Template Parameters : Type Floating point type used.","title":"Detailed Description"},{"location":"api/markdown/dsor_utils/Classes/classDigitalFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classDigitalFilter/#function-update","text":"virtual Type update( Type newValue ) =0 Reimplemented by : HighPassFilter::update , LowPassFilter::update , LowPassFilter2::update , HighPassFilter3::update , LowPassFilter3::update , LowPassFilter3MatchedZ::update , LowPassFilter3DiffApprox::update , Differentiator::update","title":"function update"},{"location":"api/markdown/dsor_utils/Classes/classDigitalFilter/#function-getoutput","text":"virtual Type getOutput() =0 Reimplemented by : Differentiator::getOutput , LowPassFilter::getOutput , HighPassFilter::getOutput , LowPassFilter2::getOutput , HighPassFilter3::getOutput , LowPassFilter3::getOutput , LowPassFilter3MatchedZ::getOutput , LowPassFilter3DiffApprox::getOutput Updated on 2023-05-26 at 16:18:58 +0000","title":"function getOutput"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter/","text":"HighPassFilter Class for high pass filter using bilinear transform. More... #include <highpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name HighPassFilter (float idt, float omega_c) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. const float * outputPointer () Detailed Description class HighPassFilter; Class for high pass filter using bilinear transform. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Multiple classes for low pass filters of different orders, inherited from the DigitalFilter class of moving filters. A low-pass filter is a filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency. Public Functions Documentation function HighPassFilter inline HighPassFilter( float idt, float omega_c ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput function configOutput inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such function outputPointer inline const float * outputPointer() Updated on 2023-05-26 at 16:18:58 +0000","title":"HighPassFilter"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter/#highpassfilter","text":"Class for high pass filter using bilinear transform. More... #include <highpass_filter.hpp> Inherits from DigitalFilter< float >","title":"HighPassFilter"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter/#public-functions","text":"Name HighPassFilter (float idt, float omega_c) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. const float * outputPointer ()","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter/#detailed-description","text":"class HighPassFilter; Class for high pass filter using bilinear transform. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Multiple classes for low pass filters of different orders, inherited from the DigitalFilter class of moving filters. A low-pass filter is a filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency.","title":"Detailed Description"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter/#function-highpassfilter","text":"inline HighPassFilter( float idt, float omega_c ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency","title":"function HighPassFilter"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput","title":"function getOutput"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter/#function-configoutput","text":"inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such","title":"function configOutput"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter/#function-outputpointer","text":"inline const float * outputPointer() Updated on 2023-05-26 at 16:18:58 +0000","title":"function outputPointer"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter3/","text":"HighPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. #include <highpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name HighPassFilter3 (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. Public Functions Documentation function HighPassFilter3 inline HighPassFilter3( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2023-05-26 at 16:18:58 +0000","title":"HighPassFilter3"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter3/#highpassfilter3","text":"Class for third order high pass filter. This is designed using the bilinear transform. #include <highpass_filter.hpp> Inherits from DigitalFilter< float >","title":"HighPassFilter3"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter3/#public-functions","text":"Name HighPassFilter3 (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter3/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter3/#function-highpassfilter3","text":"inline HighPassFilter3( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency","title":"function HighPassFilter3"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter3/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/dsor_utils/Classes/classHighPassFilter3/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2023-05-26 at 16:18:58 +0000","title":"function getOutput"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter/","text":"LowPassFilter Class for a low pass filter. More... #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter (float idt, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. const float * outputPointer () Detailed Description class LowPassFilter; Class for a low pass filter. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Multiple classes for low pass filters of different orders, inherited from the DigitalFilter class of moving filters. A low-pass filter is a filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency. Design to be a first order Butterworth low pass filter. Transformation done using the matched-Z-transform method Public Functions Documentation function LowPassFilter inline LowPassFilter( float idt, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput function configOutput inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such function outputPointer inline const float * outputPointer() Updated on 2023-05-26 at 16:18:58 +0000","title":"LowPassFilter"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter/#lowpassfilter","text":"Class for a low pass filter. More... #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter/#public-functions","text":"Name LowPassFilter (float idt, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the low pass filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. const float * outputPointer ()","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter/#detailed-description","text":"class LowPassFilter; Class for a low pass filter. Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Multiple classes for low pass filters of different orders, inherited from the DigitalFilter class of moving filters. A low-pass filter is a filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates signals with frequencies higher than the cutoff frequency. Design to be a first order Butterworth low pass filter. Transformation done using the matched-Z-transform method","title":"Detailed Description"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter/#function-lowpassfilter","text":"inline LowPassFilter( float idt, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : idt Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency","title":"function LowPassFilter"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the low pass filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput","title":"function getOutput"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter/#function-configoutput","text":"inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such","title":"function configOutput"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter/#function-outputpointer","text":"inline const float * outputPointer() Updated on 2023-05-26 at 16:18:58 +0000","title":"function outputPointer"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter2/","text":"LowPassFilter2 Class for a 2nd order low pass filter. More... #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter2 (float dt, float tau_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value. Detailed Description class LowPassFilter2; Class for a 2nd order low pass filter. Design to be a 2nd order Butterworth low pass filter. Transformation done using the bilinear transform method Public Functions Documentation function LowPassFilter2 inline LowPassFilter2( float dt, float tau_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : dt Sample time for the low pass filter tau_c The time constant for the filter \\( \\tau_c = \\frac{1}{2 pi f_c}\\) , where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput function configOutput inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such Updated on 2023-05-26 at 16:18:58 +0000","title":"LowPassFilter2"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter2/#lowpassfilter2","text":"Class for a 2nd order low pass filter. More... #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter2"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter2/#public-functions","text":"Name LowPassFilter2 (float dt, float tau_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. void configOutput (float newOutput) Force the output to a desired value.","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter2/#detailed-description","text":"class LowPassFilter2; Class for a 2nd order low pass filter. Design to be a 2nd order Butterworth low pass filter. Transformation done using the bilinear transform method","title":"Detailed Description"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter2/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter2/#function-lowpassfilter2","text":"inline LowPassFilter2( float dt, float tau_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : dt Sample time for the low pass filter tau_c The time constant for the filter \\( \\tau_c = \\frac{1}{2 pi f_c}\\) , where \\( f_c \\) is the cutoff frequency","title":"function LowPassFilter2"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter2/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter2/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput","title":"function getOutput"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter2/#function-configoutput","text":"inline void configOutput( float newOutput ) Force the output to a desired value. Parameters : newOutput The new output This can be useful when the output needs to be forced in case of extreme inputs or such Updated on 2023-05-26 at 16:18:58 +0000","title":"function configOutput"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3/","text":"LowPassFilter3 Class for third order high pass filter. This is designed using the bilinear transform. #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter3 (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. Public Functions Documentation function LowPassFilter3 inline LowPassFilter3( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2023-05-26 at 16:18:58 +0000","title":"LowPassFilter3"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3/#lowpassfilter3","text":"Class for third order high pass filter. This is designed using the bilinear transform. #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter3"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3/#public-functions","text":"Name LowPassFilter3 (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3/#function-lowpassfilter3","text":"inline LowPassFilter3( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency","title":"function LowPassFilter3"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2023-05-26 at 16:18:58 +0000","title":"function getOutput"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3DiffApprox/","text":"LowPassFilter3DiffApprox Class for third order high pass filter. This is designed using the approximated differtial approuch where s=(Z-1)/(Z*T). #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter3DiffApprox (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. Public Functions Documentation function LowPassFilter3DiffApprox inline LowPassFilter3DiffApprox( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2023-05-26 at 16:18:58 +0000","title":"LowPassFilter3DiffApprox"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3DiffApprox/#lowpassfilter3diffapprox","text":"Class for third order high pass filter. This is designed using the approximated differtial approuch where s=(Z-1)/(Z*T). #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter3DiffApprox"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3DiffApprox/#public-functions","text":"Name LowPassFilter3DiffApprox (float sampleTime, float omega_c, float ioutput =0) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3DiffApprox/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3DiffApprox/#function-lowpassfilter3diffapprox","text":"inline LowPassFilter3DiffApprox( float sampleTime, float omega_c, float ioutput =0 ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency","title":"function LowPassFilter3DiffApprox"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3DiffApprox/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3DiffApprox/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2023-05-26 at 16:18:58 +0000","title":"function getOutput"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3MatchedZ/","text":"LowPassFilter3MatchedZ Class for third order low pass filter. This is designed using the matched Z transform. #include <lowpass_filter.hpp> Inherits from DigitalFilter< float > Public Functions Name LowPassFilter3MatchedZ (float sampleTime, float omega_c) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output. Public Functions Documentation function LowPassFilter3MatchedZ inline LowPassFilter3MatchedZ( float sampleTime, float omega_c ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency function update inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update function getOutput inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2023-05-26 at 16:18:58 +0000","title":"LowPassFilter3MatchedZ"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3MatchedZ/#lowpassfilter3matchedz","text":"Class for third order low pass filter. This is designed using the matched Z transform. #include <lowpass_filter.hpp> Inherits from DigitalFilter< float >","title":"LowPassFilter3MatchedZ"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3MatchedZ/#public-functions","text":"Name LowPassFilter3MatchedZ (float sampleTime, float omega_c) Constructor to set sample time and the tau constant. virtual float update (float newValue) Update function to push new value into the filter. virtual float getOutput () Gets the output.","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3MatchedZ/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3MatchedZ/#function-lowpassfilter3matchedz","text":"inline LowPassFilter3MatchedZ( float sampleTime, float omega_c ) Constructor to set sample time and the tau constant. Parameters : sampleTime Sample time for the low pass filter omega_c Cutoff angular frequency \\( \\omega_c = 2 pi f_c\\) where \\( f_c \\) is the cutoff frequency","title":"function LowPassFilter3MatchedZ"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3MatchedZ/#function-update","text":"inline virtual float update( float newValue ) Update function to push new value into the filter. Parameters : newValue The new value after dt time Return : The new output value Reimplements : DigitalFilter::update","title":"function update"},{"location":"api/markdown/dsor_utils/Classes/classLowPassFilter3MatchedZ/#function-getoutput","text":"inline virtual float getOutput() Gets the output. Return : The output. Reimplements : DigitalFilter::getOutput Updated on 2023-05-26 at 16:18:58 +0000","title":"function getOutput"},{"location":"api/markdown/dsor_utils/Classes/classMovingAvarageFilter/","text":"MovingAvarageFilter More... #include <moving_average_filter.hpp> Public Functions Name double update (double input) Update function to push new value into the moving average filter. Detailed Description template <size_t size> class MovingAvarageFilter; Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Class for a moving average filter, inherited from the DigitalFilter class of moving filters. A moving average filter is operates by averaging a number of points from the input signal to produce each point in the output signal. Public Functions Documentation function update inline double update( double input ) Update function to push new value into the moving average filter. Parameters : input The new value after dt time Return : The new output value Updated on 2023-05-26 at 16:18:58 +0000","title":"MovingAvarageFilter"},{"location":"api/markdown/dsor_utils/Classes/classMovingAvarageFilter/#movingavaragefilter","text":"More... #include <moving_average_filter.hpp>","title":"MovingAvarageFilter"},{"location":"api/markdown/dsor_utils/Classes/classMovingAvarageFilter/#public-functions","text":"Name double update (double input) Update function to push new value into the moving average filter.","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classMovingAvarageFilter/#detailed-description","text":"template <size_t size> class MovingAvarageFilter; Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Class for a moving average filter, inherited from the DigitalFilter class of moving filters. A moving average filter is operates by averaging a number of points from the input signal to produce each point in the output signal.","title":"Detailed Description"},{"location":"api/markdown/dsor_utils/Classes/classMovingAvarageFilter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classMovingAvarageFilter/#function-update","text":"inline double update( double input ) Update function to push new value into the moving average filter. Parameters : input The new value after dt time Return : The new output value Updated on 2023-05-26 at 16:18:58 +0000","title":"function update"},{"location":"api/markdown/dsor_utils/Classes/classRateLimiter/","text":"RateLimiter More... #include <rate_limiter.hpp> Public Functions Name RateLimiter () RateLimiter (double initialValue, bool using_circular_units =false) double Calculate (double input) void setNewRateLimit (double rate_limit) Set the New Rate Limit value. double getRateLimit () Get the current Rate Limit value. double getPreviousValue () Get the current previous value. void Reset (double value) Detailed Description class RateLimiter; A class that limits the rate of change of an input value. Limits the first derivative of the signal passing through it. The output changes no faster than the specified limit. Public Functions Documentation function RateLimiter inline RateLimiter() Creates a new RateLimiter . function RateLimiter inline RateLimiter( double initialValue, bool using_circular_units =false ) Parameters : initialValue The initial value of the input. Creates a new RateLimiter with the given rate limit and initial value. function Calculate inline double Calculate( double input ) Parameters : input The input value whose slew rate is to be limited. Return : The filtered value, which will not change faster than the slew rate. Filters the input to limit its slew rate. function setNewRateLimit inline void setNewRateLimit( double rate_limit ) Set the New Rate Limit value. Parameters : rate_limit function getRateLimit inline double getRateLimit() Get the current Rate Limit value. function getPreviousValue inline double getPreviousValue() Get the current previous value. function Reset inline void Reset( double value ) Parameters : value The value to reset to. Resets the slew rate limiter to the specified value; ignores the rate limit when doing so. Updated on 2023-05-26 at 16:18:58 +0000","title":"RateLimiter"},{"location":"api/markdown/dsor_utils/Classes/classRateLimiter/#ratelimiter","text":"More... #include <rate_limiter.hpp>","title":"RateLimiter"},{"location":"api/markdown/dsor_utils/Classes/classRateLimiter/#public-functions","text":"Name RateLimiter () RateLimiter (double initialValue, bool using_circular_units =false) double Calculate (double input) void setNewRateLimit (double rate_limit) Set the New Rate Limit value. double getRateLimit () Get the current Rate Limit value. double getPreviousValue () Get the current previous value. void Reset (double value)","title":"Public Functions"},{"location":"api/markdown/dsor_utils/Classes/classRateLimiter/#detailed-description","text":"class RateLimiter; A class that limits the rate of change of an input value. Limits the first derivative of the signal passing through it. The output changes no faster than the specified limit.","title":"Detailed Description"},{"location":"api/markdown/dsor_utils/Classes/classRateLimiter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/markdown/dsor_utils/Classes/classRateLimiter/#function-ratelimiter","text":"inline RateLimiter() Creates a new RateLimiter .","title":"function RateLimiter"},{"location":"api/markdown/dsor_utils/Classes/classRateLimiter/#function-ratelimiter_1","text":"inline RateLimiter( double initialValue, bool using_circular_units =false ) Parameters : initialValue The initial value of the input. Creates a new RateLimiter with the given rate limit and initial value.","title":"function RateLimiter"},{"location":"api/markdown/dsor_utils/Classes/classRateLimiter/#function-calculate","text":"inline double Calculate( double input ) Parameters : input The input value whose slew rate is to be limited. Return : The filtered value, which will not change faster than the slew rate. Filters the input to limit its slew rate.","title":"function Calculate"},{"location":"api/markdown/dsor_utils/Classes/classRateLimiter/#function-setnewratelimit","text":"inline void setNewRateLimit( double rate_limit ) Set the New Rate Limit value. Parameters : rate_limit","title":"function setNewRateLimit"},{"location":"api/markdown/dsor_utils/Classes/classRateLimiter/#function-getratelimit","text":"inline double getRateLimit() Get the current Rate Limit value.","title":"function getRateLimit"},{"location":"api/markdown/dsor_utils/Classes/classRateLimiter/#function-getpreviousvalue","text":"inline double getPreviousValue() Get the current previous value.","title":"function getPreviousValue"},{"location":"api/markdown/dsor_utils/Classes/classRateLimiter/#function-reset","text":"inline void Reset( double value ) Parameters : value The value to reset to. Resets the slew rate limiter to the specified value; ignores the rate limit when doing so. Updated on 2023-05-26 at 16:18:58 +0000","title":"function Reset"},{"location":"api/markdown/dsor_utils/Classes/structDSOR_1_1VehicleState/","text":"DSOR::VehicleState State class - used to save the state of a vehicle (using SNAME convention) More... #include <vehicle_state.hpp> Public Attributes Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2 Detailed Description struct DSOR::VehicleState; State class - used to save the state of a vehicle (using SNAME convention) Author : Eduardo Cunha Andre Potes Marcelo Jacinto Version : 1.0.0 Date : 2022/05/26 Copyright : MIT Public Attributes Documentation variable eta1 Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; The position of the vehicle expressed in the inertial frame eta1=[x,y,z]^T variable eta2 Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; The orientation of the vehicle expressed in the inertial frame, using euler angles eta2=[roll, pitch, yaw]^T variable v1 Eigen::Vector3d v1 {0.0, 0.0, 0.0}; The body velocity of the vehicle v1=[u,v,w]^T variable v2 Eigen::Vector3d v2 {0.0, 0.0, 0.0}; The body angular velocity of the vehicle v2=[p,q,r]^T Updated on 2023-05-26 at 16:18:58 +0000","title":"DSOR::VehicleState"},{"location":"api/markdown/dsor_utils/Classes/structDSOR_1_1VehicleState/#dsorvehiclestate","text":"State class - used to save the state of a vehicle (using SNAME convention) More... #include <vehicle_state.hpp>","title":"DSOR::VehicleState"},{"location":"api/markdown/dsor_utils/Classes/structDSOR_1_1VehicleState/#public-attributes","text":"Name Eigen::Vector3d eta1 Eigen::Vector3d eta2 Eigen::Vector3d v1 Eigen::Vector3d v2","title":"Public Attributes"},{"location":"api/markdown/dsor_utils/Classes/structDSOR_1_1VehicleState/#detailed-description","text":"struct DSOR::VehicleState; State class - used to save the state of a vehicle (using SNAME convention) Author : Eduardo Cunha Andre Potes Marcelo Jacinto Version : 1.0.0 Date : 2022/05/26 Copyright : MIT","title":"Detailed Description"},{"location":"api/markdown/dsor_utils/Classes/structDSOR_1_1VehicleState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/markdown/dsor_utils/Classes/structDSOR_1_1VehicleState/#variable-eta1","text":"Eigen::Vector3d eta1 {0.0, 0.0, 0.0}; The position of the vehicle expressed in the inertial frame eta1=[x,y,z]^T","title":"variable eta1"},{"location":"api/markdown/dsor_utils/Classes/structDSOR_1_1VehicleState/#variable-eta2","text":"Eigen::Vector3d eta2 {0.0, 0.0, 0.0}; The orientation of the vehicle expressed in the inertial frame, using euler angles eta2=[roll, pitch, yaw]^T","title":"variable eta2"},{"location":"api/markdown/dsor_utils/Classes/structDSOR_1_1VehicleState/#variable-v1","text":"Eigen::Vector3d v1 {0.0, 0.0, 0.0}; The body velocity of the vehicle v1=[u,v,w]^T","title":"variable v1"},{"location":"api/markdown/dsor_utils/Classes/structDSOR_1_1VehicleState/#variable-v2","text":"Eigen::Vector3d v2 {0.0, 0.0, 0.0}; The body angular velocity of the vehicle v2=[p,q,r]^T Updated on 2023-05-26 at 16:18:58 +0000","title":"variable v2"},{"location":"api/markdown/dsor_utils/Examples/","text":"Examples Updated on 2023-05-26 at 16:18:58 +0000","title":"Examples"},{"location":"api/markdown/dsor_utils/Examples/#examples","text":"Updated on 2023-05-26 at 16:18:58 +0000","title":"Examples"},{"location":"api/markdown/dsor_utils/Modules/","text":"Modules Updated on 2023-05-26 at 16:18:58 +0000","title":"Modules"},{"location":"api/markdown/dsor_utils/Modules/#modules","text":"Updated on 2023-05-26 at 16:18:58 +0000","title":"Modules"},{"location":"api/markdown/dsor_utils/Namespaces/","text":"Namespaces namespace DSOR namespace tps Updated on 2023-05-26 at 16:18:58 +0000","title":"Namespaces"},{"location":"api/markdown/dsor_utils/Namespaces/#namespaces","text":"namespace DSOR namespace tps Updated on 2023-05-26 at 16:18:58 +0000","title":"Namespaces"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/","text":"DSOR More... Classes Name struct DSOR::VehicleState State class - used to save the state of a vehicle (using SNAME convention) Functions Name template <typename T > T saturateControlDepthUsingMinAltitude (T depth_command, T altitude_min, T measured_depth, T measured_altitude) Method to saturate the control in depth. template <typename T > T saturateControlAltitudeUsingMinAltitude (T altitude_command, T altitude_min) Method to saturate the control in altitude. template <typename T > T saturateControlDepthUsingMaxDepth (T depth_command, T max_depth) Method to saturate the control in depth. template <typename T > T saturateControlAltitudeUsingMaxDepth (T altitude_command, T measured_depth, T measured_altitude, T max_depth) Method to saturate the control in altitude. const Eigen::PermutationMatrix< 3 > NED_ENU_REFLECTION_XY (Eigen::Vector3i(1, 0, 2) ) Use reflections instead of rotations for NED <-> ENU transformation to avoid NaN/Inf floating point pollution across different axes since in NED <-> ENU the axes are perfectly aligned. template <typename T > const Eigen::DiagonalMatrix< T, 3 > NED_ENU_REFLECTION_Z (1 , 1 , - 1) template <typename T > Eigen::Quaternion< T > rot_body_rotation (const Eigen::Quaternion< T > & q) Transform a rotation (as a quaternion) from body expressed in ENU (or NED) to inertial frame to a similar rotation (as quaternion) from body expressed in NED (or ENU) to inertial frame. template <typename T > Eigen::Quaternion< T > rot_inertial_rotation (const Eigen::Quaternion< T > & q) Transform a rotation (as a quaternion) from body to inertial frame expressed in ENU (or NED) to a similar rotation (as quaternion) from body to inertial frame expressed in NED (or ENU) template <typename T > Eigen::Quaternion< T > rot_body_to_inertial (const Eigen::Quaternion< T > & q) Transform a rotation of a rigid body (as a quaternion) from body (ENU or NED) to inertial frame (ENU or NED) to a similar rotation (as quaternion) from body (NED or ENU) to inertial frame (NED or ENU) template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_body_enu_ned (const Eigen::Matrix< T, 3, 1 > & vec) Transform vector in ENU (or NED) to NED (or ENU), expressed in body-frame. +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_between_arbitrary_ref (const Eigen::Matrix< T, 3, 1 > & vec, const Eigen::Quaternion< T > & q) Transform a vector in a given frame of reference to another frame of reference. template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_inertial_enu_ned (const Eigen::Matrix< T, 3, 1 > & vec) Transform vector in ENU (or NED) to NED (or ENU), expressed in inertial-frame. ENU <\u2014> NED - Invert the Z axis and switch the XY axis. template <typename T > Eigen::Matrix< T, 3, 3 > transform_cov3_body_enu_ned (const Eigen::Matrix< T, 3, 3 > & cov_in) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in body-frame. template <typename T > Eigen::Matrix< T, 3, 3 > transform_cov3_inertial_enu_ned (const Eigen::Matrix< T, 3, 3 > & cov_in) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in inertial-frame. template <typename T > int sign (T v) Returns the sign of the number. template <typename T > T saturation (T value, T min, T max) A function that saturates 2 values linearly. template <typename T > bool approximatelyEquals (T a, T b, T tolerance =1e-6) A function to check if two numbers are equal (int, float, double, etc) template <typename T > Eigen::Matrix< T, 3, 1 > quaternion_to_euler (const Eigen::Quaternion< T > & q) Function to convert from quaternion to (roll, pitch and yaw), according to Z-Y-X convention This function is from: https://github.com/mavlink/mavros/issues/444 and the logic is also available at: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . template <typename T > Eigen::Quaternion< T > euler_to_quaternion (const Eigen::Matrix< T, 3, 1 > & v) Converts a vector of euler angles according to Z-Y-X convention into a quaternion. template <typename T > T yaw_from_quaternion (const Eigen::Quaternion< T > & q) Gets the yaw angle from a quaternion (assumed a Z-Y-X rotation) NOTE: this function is based on: https://github.com/mavlink/mavros/blob/ros2/mavros/src/lib/ftf_quaternion_utils.cpp which in turn has the theory explained in: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . template <typename T > T wrapTo360 (T angle) Wrap angle between [0, 2PI]. template <typename T > T wrapTo2pi (T angle) Wrap angle between [0, 2PI]. template <typename T > T wrapTopi (T angle) Wrap angle between [-PI, PI]. template <typename T > T radToDeg (T angle) Convert an angle in radian to degrees. template <typename T > T degToRad (T angle) Convert an angle in degrees to radians. template <typename T > T angleDiffRadians (T a, T b) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. template <typename T > T angleDiffDegrees (T a, T b) Method to calculate the diference between angles correctly even if they wrap between -180 and 180. template <typename T > Eigen::Matrix< T, 3, 3 > computeSkewSymmetric3 (const Eigen::Matrix< T, 3, 1 > & v) Compute the 3x3 skew-symmetric matrix from a vector 3x1. template <typename T > Eigen::Matrix< T, 2, 2 > computeSkewSymmetric2 (T c) Compute the 2x2 skew-symmetric matrix from a constant (int, float or double) template <typename T > Eigen::Matrix< T, 3, 3 > rotationAngularBodyToInertial (const Eigen::Matrix< T, 3, 1 > & v) Compute the rotation matrix that converts angular velocities expressed in the body frame to angular velocities expressed in the inertial frame (according to Z-Y-X convention) - makes use of small angle approximation. template <typename T > Eigen::Matrix< T, 3, 3 > rotationBodyToInertial (const Eigen::Matrix< T, 3, 1 > & v) Method that returns a rotation matrix from body frame to inertial frame, assuming a Z-Y-X convention. template <typename T > Eigen::Matrix< T, 3, 1 > spherical_to_cartesian (T bearing, T elevation, T range) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Attributes Name const Eigen::Quaternion< T > ENU_NED_INERTIAL_Q Static quaternion to convert a rotation expressed in ENU to a rotation expressed in NED (Z->Y->X convention) on the inertial frame Rotate PI/2 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. const Eigen::Quaternion< T > ENU_NED_BODY_Q Static quaternion to convert a rotation expressed in ENU body frame (ROS base_link) to a rotation expressed in NED body frame (Z->Y->X convention) Rotate 0 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. const Eigen::Quaternion< T > BODY_ENU_NED_Q Static quaternion needed for rotating vectors in body frames between ENU and NED +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). const Eigen::Transform< T, 3, Eigen::Affine > BODY_ENU_NED_TF Static affine matrix to roate vectors ENU (or NED) -> NED (or ENU) expressed in body frame +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Detailed Description Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 10/02/2022 License: MIT File: [vehicle_saturations.hpp] Brief: Defines functions used for saturating the vehicle inputs to the system Authors: Andr\u00e9 Potes ( andre.potes@gmail.com ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [frames.hpp] Brief: Defines all functions related to conversions between ENU do NED frames and vice-versa NOTE: Most of this code is adapted from mavros https://github.com/mavlink/mavros/blob/master/mavros/src/lib/ftf_frame_conversions.cpp which had as authors Nuno Marques ( n.marques21@hotmail.com ) and Eddy Scott ( scott.edward@aurora.aero ) Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [math.hpp] Brief: Defines all functions related to general math functions that can be used anywhere Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Andre Potes ( andre.potes@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [rotations.hpp] Brief: Defines all functions related to angle wrapping, rotation matrices, euler angles, convertion to quaternions, etc. Authors: Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [spherical_coordinates.hpp] Brief: Defines all functions related to spherical coordinates conversions Functions Documentation function saturateControlDepthUsingMinAltitude template <typename T > inline T saturateControlDepthUsingMinAltitude( T depth_command, T altitude_min, T measured_depth, T measured_altitude ) Method to saturate the control in depth. Parameters : depth_command The input command in depth altitude_min The minimum altitude (positive distance from the vehicle to the bottom in m) measured_depth The measured depth of the vehicle measured_altitude The measured altitude of the vehicle Return : The saturated control of depth such that the vehicle does not surpass the minimum altitude function saturateControlAltitudeUsingMinAltitude template <typename T > inline T saturateControlAltitudeUsingMinAltitude( T altitude_command, T altitude_min ) Method to saturate the control in altitude. Parameters : altitude_command The input command in altitude altitude_min The minimum altitude to keep from the ground Return : The output command of the altitude saturated such that the vehicle does not surpass the minimum altitude function saturateControlDepthUsingMaxDepth template <typename T > inline T saturateControlDepthUsingMaxDepth( T depth_command, T max_depth ) Method to saturate the control in depth. Parameters : depth_command The input command in depth max_depth The max depth Return : The output command of the depth saturated such that the vehicle does not surpass the maximum depth function saturateControlAltitudeUsingMaxDepth template <typename T > inline T saturateControlAltitudeUsingMaxDepth( T altitude_command, T measured_depth, T measured_altitude, T max_depth ) Method to saturate the control in altitude. Parameters : altitude_command The input command in altitude measured_depth The measured depth of the vehicle measured_altitude The measured altitude of the vehicle max_depth The maximum depth allowed Return : The output command of the altitude saturated such that the vehicle does not surpass the maximum depth function NED_ENU_REFLECTION_XY static const Eigen::PermutationMatrix< 3 > NED_ENU_REFLECTION_XY( Eigen::Vector3i(1, 0, 2) ) Use reflections instead of rotations for NED <-> ENU transformation to avoid NaN/Inf floating point pollution across different axes since in NED <-> ENU the axes are perfectly aligned. function NED_ENU_REFLECTION_Z template <typename T > static const Eigen::DiagonalMatrix< T, 3 > NED_ENU_REFLECTION_Z( 1 , 1 , - 1 ) function rot_body_rotation template <typename T > inline Eigen::Quaternion< T > rot_body_rotation( const Eigen::Quaternion< T > & q ) Transform a rotation (as a quaternion) from body expressed in ENU (or NED) to inertial frame to a similar rotation (as quaternion) from body expressed in NED (or ENU) to inertial frame. Parameters : q quaternion representing a rotation: body frame ENU (or NED) -> inertial frame (in arbitrary convention) Return : quaternion represeting a rotation: body frame NED (or ENU) -> inertial frame (in arbitrary convention) NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference. function rot_inertial_rotation template <typename T > inline Eigen::Quaternion< T > rot_inertial_rotation( const Eigen::Quaternion< T > & q ) Transform a rotation (as a quaternion) from body to inertial frame expressed in ENU (or NED) to a similar rotation (as quaternion) from body to inertial frame expressed in NED (or ENU) Parameters : q quaternion representing a rotation: body frame (in arbitrary convention) -> inertial frame ENU (or NED) Return : quaternion represeting a rotation: body frame (in arbitrary convention) -> inertial frame NED (or ENU) NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference. function rot_body_to_inertial template <typename T > inline Eigen::Quaternion< T > rot_body_to_inertial( const Eigen::Quaternion< T > & q ) Transform a rotation of a rigid body (as a quaternion) from body (ENU or NED) to inertial frame (ENU or NED) to a similar rotation (as quaternion) from body (NED or ENU) to inertial frame (NED or ENU) Parameters : q quaternion representing a rotation: body frame (ENU or NED) -> inertial frame (ENU or NED) Return : quaternion representing a rotation: body frame (NED or ENU) -> inertial frame (NED or ENU) NOTE: This function is usefull to convert the attitude of a vehicle from \"ROS\" quaternion to a typicall literature quaternion (where both the body frame and inertial frames are in ENU). If you are converting a quaternion that expresses the orientation of a sensor with respect to a rigid body's body frame (and not the inertial frame), then you DO NOT WANT TO USE THIS FUNCTION. Body-FRAME NED is not the same as INERTIAL-FRAME NED (this comes once again from the fact that in ned body the x-y axis don't switch like in inertial frame) as explained in the documentation. Essencial only use this if you are representing a body in inertial frame! NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference. function transform_vect_body_enu_ned template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_body_enu_ned( const Eigen::Matrix< T, 3, 1 > & vec ) Transform vector in ENU (or NED) to NED (or ENU), expressed in body-frame. +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Parameters : vec Vector expressed in body-frame (ENU or NED) Return : Vector expressed in body-frame (NED or ENU) function transform_vect_between_arbitrary_ref template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_between_arbitrary_ref( const Eigen::Matrix< T, 3, 1 > & vec, const Eigen::Quaternion< T > & q ) Transform a vector in a given frame of reference to another frame of reference. Parameters : vec Vector expressed in the original frame of reference q Quaternion that expresses the orientation of the original frame of reference with respect to the final frame of reference Return : Vector expressed in the new frame of reference function transform_vect_inertial_enu_ned template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_inertial_enu_ned( const Eigen::Matrix< T, 3, 1 > & vec ) Transform vector in ENU (or NED) to NED (or ENU), expressed in inertial-frame. ENU <\u2014> NED - Invert the Z axis and switch the XY axis. Parameters : vec Vector expressed in inertial-frame (ENU or NED) Return : Vector expressed in inertial-frame (NED or ENU) function transform_cov3_body_enu_ned template <typename T > inline Eigen::Matrix< T, 3, 3 > transform_cov3_body_enu_ned( const Eigen::Matrix< T, 3, 3 > & cov_in ) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in body-frame. Parameters : cov_in Covariance matrix expressed in body-frame (ENU or NED) Return : Covariance matrix expressed in body-frame (NED or ENU) NOTE: Check https://robotics.stackexchange.com/questions/2556/how-to-rotate-covariance for a detailed explanation of the actual conversion proof for covariance matrices function transform_cov3_inertial_enu_ned template <typename T > inline Eigen::Matrix< T, 3, 3 > transform_cov3_inertial_enu_ned( const Eigen::Matrix< T, 3, 3 > & cov_in ) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in inertial-frame. Parameters : cov_in Covariance matrix expressed in inertial-frame (ENU or NED) Return : Covariance matrix expressed in inertial-frame (NED or ENU) NOTE: Check https://robotics.stackexchange.com/questions/2556/how-to-rotate-covariance for a detailed explanation of the actual conversion proof for covariance matrices function sign template <typename T > inline int sign( T v ) Returns the sign of the number. Parameters : v A number Return : 1 if value is positive 0 if value is 0 -1 if value is negative function saturation template <typename T > inline T saturation( T value, T min, T max ) A function that saturates 2 values linearly. Parameters : value A number to saturate min The minimum value max The maximum value Return : A value such that value in [min, max] function approximatelyEquals template <typename T > inline bool approximatelyEquals( T a, T b, T tolerance =1e-6 ) A function to check if two numbers are equal (int, float, double, etc) Parameters : a a number to compare b another number to compare tolerance tolerance of comparison Return : A boolean for true if equal within tolerance, or otherwise function quaternion_to_euler template <typename T > inline Eigen::Matrix< T, 3, 1 > quaternion_to_euler( const Eigen::Quaternion< T > & q ) Function to convert from quaternion to (roll, pitch and yaw), according to Z-Y-X convention This function is from: https://github.com/mavlink/mavros/issues/444 and the logic is also available at: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . Parameters : q An eigen quaternion Return : A Vector with the [roll, pitch, yaw] obtained according to Z-Y-X convention function euler_to_quaternion template <typename T > inline Eigen::Quaternion< T > euler_to_quaternion( const Eigen::Matrix< T, 3, 1 > & v ) Converts a vector of euler angles according to Z-Y-X convention into a quaternion. Parameters : v An eigen vector of either floats or doubles [roll, pitch, yaw] Return : An Eigen Quaternion function yaw_from_quaternion template <typename T > inline T yaw_from_quaternion( const Eigen::Quaternion< T > & q ) Gets the yaw angle from a quaternion (assumed a Z-Y-X rotation) NOTE: this function is based on: https://github.com/mavlink/mavros/blob/ros2/mavros/src/lib/ftf_quaternion_utils.cpp which in turn has the theory explained in: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . Parameters : q A eigen quaternion Return : The yaw angle in radians (assumed a Z-Y-X rotation) function wrapTo360 template <typename T > inline T wrapTo360( T angle ) Wrap angle between [0, 2PI]. Parameters : angle angle in radians Return : The wraped angle function wrapTo2pi template <typename T > inline T wrapTo2pi( T angle ) Wrap angle between [0, 2PI]. Parameters : angle angle in radians Return : The wraped angle function wrapTopi template <typename T > inline T wrapTopi( T angle ) Wrap angle between [-PI, PI]. Parameters : angle angle in radians Return : The wraped angle function radToDeg template <typename T > inline T radToDeg( T angle ) Convert an angle in radian to degrees. Parameters : angle in radians Return : angle in degrees function degToRad template <typename T > inline T degToRad( T angle ) Convert an angle in degrees to radians. Parameters : angle in degrees Return : angle in radians function angleDiffRadians template <typename T > inline T angleDiffRadians( T a, T b ) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. Parameters : a angle 1 in radians b angle 2 in radians Return : The minimum difference between the two angles function angleDiffDegrees template <typename T > inline T angleDiffDegrees( T a, T b ) Method to calculate the diference between angles correctly even if they wrap between -180 and 180. Parameters : a angle 1 in radians b angle 2 in radians Return : The minimum difference between the two angles function computeSkewSymmetric3 template <typename T > inline Eigen::Matrix< T, 3, 3 > computeSkewSymmetric3( const Eigen::Matrix< T, 3, 1 > & v ) Compute the 3x3 skew-symmetric matrix from a vector 3x1. Parameters : v A vector with 3 elements Return : A 3x3 skew-symmetric matrix function computeSkewSymmetric2 template <typename T > inline Eigen::Matrix< T, 2, 2 > computeSkewSymmetric2( T c ) Compute the 2x2 skew-symmetric matrix from a constant (int, float or double) Parameters : v A constant Return : A 2x2 skew-symmetric matrix function rotationAngularBodyToInertial template <typename T > inline Eigen::Matrix< T, 3, 3 > rotationAngularBodyToInertial( const Eigen::Matrix< T, 3, 1 > & v ) Compute the rotation matrix that converts angular velocities expressed in the body frame to angular velocities expressed in the inertial frame (according to Z-Y-X convention) - makes use of small angle approximation. Parameters : v A vector with 3 elements (roll, pitch, yaw) Return : A 3x3 rotation matrix function rotationBodyToInertial template <typename T > inline Eigen::Matrix< T, 3, 3 > rotationBodyToInertial( const Eigen::Matrix< T, 3, 1 > & v ) Method that returns a rotation matrix from body frame to inertial frame, assuming a Z-Y-X convention. Parameters : v A vector with euler angles (roll, pith, yaw) according to Z-Y-X convention Return : A 3x3 rotation matrix function spherical_to_cartesian template <typename T > Eigen::Matrix< T, 3, 1 > spherical_to_cartesian( T bearing, T elevation, T range ) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Parameters : bearing Horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation Angle measured between the horizontal and the vehicle line of sight to the object range Distance to the object bearing Horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation Angle measured between the horizontal and the vehicle line of sight to the object range Distance to the object Return : Eigen Vector with cartesian coordinates Eigen Vector with cartesian coordinates Authors: Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: spherical_coordinates.cpp Brief: Defines all functions related to spherical coordinates conversions Attributes Documentation variable ENU_NED_INERTIAL_Q static const Eigen::Quaternion< T > ENU_NED_INERTIAL_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, M_PI_2)); Static quaternion to convert a rotation expressed in ENU to a rotation expressed in NED (Z->Y->X convention) on the inertial frame Rotate PI/2 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. NOTE: this quaternion is as valid as the quaternion representing the rotation from NED to ENU (quaternion ambiguity) on the inertial frame variable ENU_NED_BODY_Q static const Eigen::Quaternion< T > ENU_NED_BODY_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, 0.0)); Static quaternion to convert a rotation expressed in ENU body frame (ROS base_link) to a rotation expressed in NED body frame (Z->Y->X convention) Rotate 0 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. NOTE: this quaternion is as valid as the quaternion representing the rotation from NED to ENU (quaternion ambiguity) on the body frame variable BODY_ENU_NED_Q static const Eigen::Quaternion< T > BODY_ENU_NED_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, 0.0)); Static quaternion needed for rotating vectors in body frames between ENU and NED +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). variable BODY_ENU_NED_TF static const Eigen::Transform< T, 3, Eigen::Affine > BODY_ENU_NED_TF = Eigen::Transform<T, 3, Eigen::Affine>(BODY_ENU_NED_Q<T>); Static affine matrix to roate vectors ENU (or NED) -> NED (or ENU) expressed in body frame +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Updated on 2023-05-26 at 16:18:58 +0000","title":"DSOR"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#dsor","text":"More...","title":"DSOR"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#classes","text":"Name struct DSOR::VehicleState State class - used to save the state of a vehicle (using SNAME convention)","title":"Classes"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#functions","text":"Name template <typename T > T saturateControlDepthUsingMinAltitude (T depth_command, T altitude_min, T measured_depth, T measured_altitude) Method to saturate the control in depth. template <typename T > T saturateControlAltitudeUsingMinAltitude (T altitude_command, T altitude_min) Method to saturate the control in altitude. template <typename T > T saturateControlDepthUsingMaxDepth (T depth_command, T max_depth) Method to saturate the control in depth. template <typename T > T saturateControlAltitudeUsingMaxDepth (T altitude_command, T measured_depth, T measured_altitude, T max_depth) Method to saturate the control in altitude. const Eigen::PermutationMatrix< 3 > NED_ENU_REFLECTION_XY (Eigen::Vector3i(1, 0, 2) ) Use reflections instead of rotations for NED <-> ENU transformation to avoid NaN/Inf floating point pollution across different axes since in NED <-> ENU the axes are perfectly aligned. template <typename T > const Eigen::DiagonalMatrix< T, 3 > NED_ENU_REFLECTION_Z (1 , 1 , - 1) template <typename T > Eigen::Quaternion< T > rot_body_rotation (const Eigen::Quaternion< T > & q) Transform a rotation (as a quaternion) from body expressed in ENU (or NED) to inertial frame to a similar rotation (as quaternion) from body expressed in NED (or ENU) to inertial frame. template <typename T > Eigen::Quaternion< T > rot_inertial_rotation (const Eigen::Quaternion< T > & q) Transform a rotation (as a quaternion) from body to inertial frame expressed in ENU (or NED) to a similar rotation (as quaternion) from body to inertial frame expressed in NED (or ENU) template <typename T > Eigen::Quaternion< T > rot_body_to_inertial (const Eigen::Quaternion< T > & q) Transform a rotation of a rigid body (as a quaternion) from body (ENU or NED) to inertial frame (ENU or NED) to a similar rotation (as quaternion) from body (NED or ENU) to inertial frame (NED or ENU) template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_body_enu_ned (const Eigen::Matrix< T, 3, 1 > & vec) Transform vector in ENU (or NED) to NED (or ENU), expressed in body-frame. +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_between_arbitrary_ref (const Eigen::Matrix< T, 3, 1 > & vec, const Eigen::Quaternion< T > & q) Transform a vector in a given frame of reference to another frame of reference. template <typename T > Eigen::Matrix< T, 3, 1 > transform_vect_inertial_enu_ned (const Eigen::Matrix< T, 3, 1 > & vec) Transform vector in ENU (or NED) to NED (or ENU), expressed in inertial-frame. ENU <\u2014> NED - Invert the Z axis and switch the XY axis. template <typename T > Eigen::Matrix< T, 3, 3 > transform_cov3_body_enu_ned (const Eigen::Matrix< T, 3, 3 > & cov_in) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in body-frame. template <typename T > Eigen::Matrix< T, 3, 3 > transform_cov3_inertial_enu_ned (const Eigen::Matrix< T, 3, 3 > & cov_in) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in inertial-frame. template <typename T > int sign (T v) Returns the sign of the number. template <typename T > T saturation (T value, T min, T max) A function that saturates 2 values linearly. template <typename T > bool approximatelyEquals (T a, T b, T tolerance =1e-6) A function to check if two numbers are equal (int, float, double, etc) template <typename T > Eigen::Matrix< T, 3, 1 > quaternion_to_euler (const Eigen::Quaternion< T > & q) Function to convert from quaternion to (roll, pitch and yaw), according to Z-Y-X convention This function is from: https://github.com/mavlink/mavros/issues/444 and the logic is also available at: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . template <typename T > Eigen::Quaternion< T > euler_to_quaternion (const Eigen::Matrix< T, 3, 1 > & v) Converts a vector of euler angles according to Z-Y-X convention into a quaternion. template <typename T > T yaw_from_quaternion (const Eigen::Quaternion< T > & q) Gets the yaw angle from a quaternion (assumed a Z-Y-X rotation) NOTE: this function is based on: https://github.com/mavlink/mavros/blob/ros2/mavros/src/lib/ftf_quaternion_utils.cpp which in turn has the theory explained in: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . template <typename T > T wrapTo360 (T angle) Wrap angle between [0, 2PI]. template <typename T > T wrapTo2pi (T angle) Wrap angle between [0, 2PI]. template <typename T > T wrapTopi (T angle) Wrap angle between [-PI, PI]. template <typename T > T radToDeg (T angle) Convert an angle in radian to degrees. template <typename T > T degToRad (T angle) Convert an angle in degrees to radians. template <typename T > T angleDiffRadians (T a, T b) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. template <typename T > T angleDiffDegrees (T a, T b) Method to calculate the diference between angles correctly even if they wrap between -180 and 180. template <typename T > Eigen::Matrix< T, 3, 3 > computeSkewSymmetric3 (const Eigen::Matrix< T, 3, 1 > & v) Compute the 3x3 skew-symmetric matrix from a vector 3x1. template <typename T > Eigen::Matrix< T, 2, 2 > computeSkewSymmetric2 (T c) Compute the 2x2 skew-symmetric matrix from a constant (int, float or double) template <typename T > Eigen::Matrix< T, 3, 3 > rotationAngularBodyToInertial (const Eigen::Matrix< T, 3, 1 > & v) Compute the rotation matrix that converts angular velocities expressed in the body frame to angular velocities expressed in the inertial frame (according to Z-Y-X convention) - makes use of small angle approximation. template <typename T > Eigen::Matrix< T, 3, 3 > rotationBodyToInertial (const Eigen::Matrix< T, 3, 1 > & v) Method that returns a rotation matrix from body frame to inertial frame, assuming a Z-Y-X convention. template <typename T > Eigen::Matrix< T, 3, 1 > spherical_to_cartesian (T bearing, T elevation, T range) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes.","title":"Functions"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#attributes","text":"Name const Eigen::Quaternion< T > ENU_NED_INERTIAL_Q Static quaternion to convert a rotation expressed in ENU to a rotation expressed in NED (Z->Y->X convention) on the inertial frame Rotate PI/2 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. const Eigen::Quaternion< T > ENU_NED_BODY_Q Static quaternion to convert a rotation expressed in ENU body frame (ROS base_link) to a rotation expressed in NED body frame (Z->Y->X convention) Rotate 0 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. const Eigen::Quaternion< T > BODY_ENU_NED_Q Static quaternion needed for rotating vectors in body frames between ENU and NED +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). const Eigen::Transform< T, 3, Eigen::Affine > BODY_ENU_NED_TF Static affine matrix to roate vectors ENU (or NED) -> NED (or ENU) expressed in body frame +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU).","title":"Attributes"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#detailed-description","text":"Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 10/02/2022 License: MIT File: [vehicle_saturations.hpp] Brief: Defines functions used for saturating the vehicle inputs to the system Authors: Andr\u00e9 Potes ( andre.potes@gmail.com ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [frames.hpp] Brief: Defines all functions related to conversions between ENU do NED frames and vice-versa NOTE: Most of this code is adapted from mavros https://github.com/mavlink/mavros/blob/master/mavros/src/lib/ftf_frame_conversions.cpp which had as authors Nuno Marques ( n.marques21@hotmail.com ) and Eddy Scott ( scott.edward@aurora.aero ) Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [math.hpp] Brief: Defines all functions related to general math functions that can be used anywhere Authors: Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Andre Potes ( andre.potes@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [rotations.hpp] Brief: Defines all functions related to angle wrapping, rotation matrices, euler angles, convertion to quaternions, etc. Authors: Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: [spherical_coordinates.hpp] Brief: Defines all functions related to spherical coordinates conversions","title":"Detailed Description"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-saturatecontroldepthusingminaltitude","text":"template <typename T > inline T saturateControlDepthUsingMinAltitude( T depth_command, T altitude_min, T measured_depth, T measured_altitude ) Method to saturate the control in depth. Parameters : depth_command The input command in depth altitude_min The minimum altitude (positive distance from the vehicle to the bottom in m) measured_depth The measured depth of the vehicle measured_altitude The measured altitude of the vehicle Return : The saturated control of depth such that the vehicle does not surpass the minimum altitude","title":"function saturateControlDepthUsingMinAltitude"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-saturatecontrolaltitudeusingminaltitude","text":"template <typename T > inline T saturateControlAltitudeUsingMinAltitude( T altitude_command, T altitude_min ) Method to saturate the control in altitude. Parameters : altitude_command The input command in altitude altitude_min The minimum altitude to keep from the ground Return : The output command of the altitude saturated such that the vehicle does not surpass the minimum altitude","title":"function saturateControlAltitudeUsingMinAltitude"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-saturatecontroldepthusingmaxdepth","text":"template <typename T > inline T saturateControlDepthUsingMaxDepth( T depth_command, T max_depth ) Method to saturate the control in depth. Parameters : depth_command The input command in depth max_depth The max depth Return : The output command of the depth saturated such that the vehicle does not surpass the maximum depth","title":"function saturateControlDepthUsingMaxDepth"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-saturatecontrolaltitudeusingmaxdepth","text":"template <typename T > inline T saturateControlAltitudeUsingMaxDepth( T altitude_command, T measured_depth, T measured_altitude, T max_depth ) Method to saturate the control in altitude. Parameters : altitude_command The input command in altitude measured_depth The measured depth of the vehicle measured_altitude The measured altitude of the vehicle max_depth The maximum depth allowed Return : The output command of the altitude saturated such that the vehicle does not surpass the maximum depth","title":"function saturateControlAltitudeUsingMaxDepth"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-ned_enu_reflection_xy","text":"static const Eigen::PermutationMatrix< 3 > NED_ENU_REFLECTION_XY( Eigen::Vector3i(1, 0, 2) ) Use reflections instead of rotations for NED <-> ENU transformation to avoid NaN/Inf floating point pollution across different axes since in NED <-> ENU the axes are perfectly aligned.","title":"function NED_ENU_REFLECTION_XY"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-ned_enu_reflection_z","text":"template <typename T > static const Eigen::DiagonalMatrix< T, 3 > NED_ENU_REFLECTION_Z( 1 , 1 , - 1 )","title":"function NED_ENU_REFLECTION_Z"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-rot_body_rotation","text":"template <typename T > inline Eigen::Quaternion< T > rot_body_rotation( const Eigen::Quaternion< T > & q ) Transform a rotation (as a quaternion) from body expressed in ENU (or NED) to inertial frame to a similar rotation (as quaternion) from body expressed in NED (or ENU) to inertial frame. Parameters : q quaternion representing a rotation: body frame ENU (or NED) -> inertial frame (in arbitrary convention) Return : quaternion represeting a rotation: body frame NED (or ENU) -> inertial frame (in arbitrary convention) NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference.","title":"function rot_body_rotation"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-rot_inertial_rotation","text":"template <typename T > inline Eigen::Quaternion< T > rot_inertial_rotation( const Eigen::Quaternion< T > & q ) Transform a rotation (as a quaternion) from body to inertial frame expressed in ENU (or NED) to a similar rotation (as quaternion) from body to inertial frame expressed in NED (or ENU) Parameters : q quaternion representing a rotation: body frame (in arbitrary convention) -> inertial frame ENU (or NED) Return : quaternion represeting a rotation: body frame (in arbitrary convention) -> inertial frame NED (or ENU) NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference.","title":"function rot_inertial_rotation"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-rot_body_to_inertial","text":"template <typename T > inline Eigen::Quaternion< T > rot_body_to_inertial( const Eigen::Quaternion< T > & q ) Transform a rotation of a rigid body (as a quaternion) from body (ENU or NED) to inertial frame (ENU or NED) to a similar rotation (as quaternion) from body (NED or ENU) to inertial frame (NED or ENU) Parameters : q quaternion representing a rotation: body frame (ENU or NED) -> inertial frame (ENU or NED) Return : quaternion representing a rotation: body frame (NED or ENU) -> inertial frame (NED or ENU) NOTE: This function is usefull to convert the attitude of a vehicle from \"ROS\" quaternion to a typicall literature quaternion (where both the body frame and inertial frames are in ENU). If you are converting a quaternion that expresses the orientation of a sensor with respect to a rigid body's body frame (and not the inertial frame), then you DO NOT WANT TO USE THIS FUNCTION. Body-FRAME NED is not the same as INERTIAL-FRAME NED (this comes once again from the fact that in ned body the x-y axis don't switch like in inertial frame) as explained in the documentation. Essencial only use this if you are representing a body in inertial frame! NOTE: Check http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/ for more details behind these type of transformations towards obtaining rotations in different frames of reference.","title":"function rot_body_to_inertial"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-transform_vect_body_enu_ned","text":"template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_body_enu_ned( const Eigen::Matrix< T, 3, 1 > & vec ) Transform vector in ENU (or NED) to NED (or ENU), expressed in body-frame. +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Parameters : vec Vector expressed in body-frame (ENU or NED) Return : Vector expressed in body-frame (NED or ENU)","title":"function transform_vect_body_enu_ned"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-transform_vect_between_arbitrary_ref","text":"template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_between_arbitrary_ref( const Eigen::Matrix< T, 3, 1 > & vec, const Eigen::Quaternion< T > & q ) Transform a vector in a given frame of reference to another frame of reference. Parameters : vec Vector expressed in the original frame of reference q Quaternion that expresses the orientation of the original frame of reference with respect to the final frame of reference Return : Vector expressed in the new frame of reference","title":"function transform_vect_between_arbitrary_ref"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-transform_vect_inertial_enu_ned","text":"template <typename T > inline Eigen::Matrix< T, 3, 1 > transform_vect_inertial_enu_ned( const Eigen::Matrix< T, 3, 1 > & vec ) Transform vector in ENU (or NED) to NED (or ENU), expressed in inertial-frame. ENU <\u2014> NED - Invert the Z axis and switch the XY axis. Parameters : vec Vector expressed in inertial-frame (ENU or NED) Return : Vector expressed in inertial-frame (NED or ENU)","title":"function transform_vect_inertial_enu_ned"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-transform_cov3_body_enu_ned","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > transform_cov3_body_enu_ned( const Eigen::Matrix< T, 3, 3 > & cov_in ) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in body-frame. Parameters : cov_in Covariance matrix expressed in body-frame (ENU or NED) Return : Covariance matrix expressed in body-frame (NED or ENU) NOTE: Check https://robotics.stackexchange.com/questions/2556/how-to-rotate-covariance for a detailed explanation of the actual conversion proof for covariance matrices","title":"function transform_cov3_body_enu_ned"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-transform_cov3_inertial_enu_ned","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > transform_cov3_inertial_enu_ned( const Eigen::Matrix< T, 3, 3 > & cov_in ) Transform 3x3 covariance matrix in ENU (or NED) to NED (or ENU), expressed in inertial-frame. Parameters : cov_in Covariance matrix expressed in inertial-frame (ENU or NED) Return : Covariance matrix expressed in inertial-frame (NED or ENU) NOTE: Check https://robotics.stackexchange.com/questions/2556/how-to-rotate-covariance for a detailed explanation of the actual conversion proof for covariance matrices","title":"function transform_cov3_inertial_enu_ned"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-sign","text":"template <typename T > inline int sign( T v ) Returns the sign of the number. Parameters : v A number Return : 1 if value is positive 0 if value is 0 -1 if value is negative","title":"function sign"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-saturation","text":"template <typename T > inline T saturation( T value, T min, T max ) A function that saturates 2 values linearly. Parameters : value A number to saturate min The minimum value max The maximum value Return : A value such that value in [min, max]","title":"function saturation"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-approximatelyequals","text":"template <typename T > inline bool approximatelyEquals( T a, T b, T tolerance =1e-6 ) A function to check if two numbers are equal (int, float, double, etc) Parameters : a a number to compare b another number to compare tolerance tolerance of comparison Return : A boolean for true if equal within tolerance, or otherwise","title":"function approximatelyEquals"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-quaternion_to_euler","text":"template <typename T > inline Eigen::Matrix< T, 3, 1 > quaternion_to_euler( const Eigen::Quaternion< T > & q ) Function to convert from quaternion to (roll, pitch and yaw), according to Z-Y-X convention This function is from: https://github.com/mavlink/mavros/issues/444 and the logic is also available at: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . Parameters : q An eigen quaternion Return : A Vector with the [roll, pitch, yaw] obtained according to Z-Y-X convention","title":"function quaternion_to_euler"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-euler_to_quaternion","text":"template <typename T > inline Eigen::Quaternion< T > euler_to_quaternion( const Eigen::Matrix< T, 3, 1 > & v ) Converts a vector of euler angles according to Z-Y-X convention into a quaternion. Parameters : v An eigen vector of either floats or doubles [roll, pitch, yaw] Return : An Eigen Quaternion","title":"function euler_to_quaternion"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-yaw_from_quaternion","text":"template <typename T > inline T yaw_from_quaternion( const Eigen::Quaternion< T > & q ) Gets the yaw angle from a quaternion (assumed a Z-Y-X rotation) NOTE: this function is based on: https://github.com/mavlink/mavros/blob/ros2/mavros/src/lib/ftf_quaternion_utils.cpp which in turn has the theory explained in: https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles . Parameters : q A eigen quaternion Return : The yaw angle in radians (assumed a Z-Y-X rotation)","title":"function yaw_from_quaternion"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-wrapto360","text":"template <typename T > inline T wrapTo360( T angle ) Wrap angle between [0, 2PI]. Parameters : angle angle in radians Return : The wraped angle","title":"function wrapTo360"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-wrapto2pi","text":"template <typename T > inline T wrapTo2pi( T angle ) Wrap angle between [0, 2PI]. Parameters : angle angle in radians Return : The wraped angle","title":"function wrapTo2pi"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-wraptopi","text":"template <typename T > inline T wrapTopi( T angle ) Wrap angle between [-PI, PI]. Parameters : angle angle in radians Return : The wraped angle","title":"function wrapTopi"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-radtodeg","text":"template <typename T > inline T radToDeg( T angle ) Convert an angle in radian to degrees. Parameters : angle in radians Return : angle in degrees","title":"function radToDeg"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-degtorad","text":"template <typename T > inline T degToRad( T angle ) Convert an angle in degrees to radians. Parameters : angle in degrees Return : angle in radians","title":"function degToRad"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-anglediffradians","text":"template <typename T > inline T angleDiffRadians( T a, T b ) Method to calculate the diference between angles correctly even if they wrap between -pi and pi. Parameters : a angle 1 in radians b angle 2 in radians Return : The minimum difference between the two angles","title":"function angleDiffRadians"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-anglediffdegrees","text":"template <typename T > inline T angleDiffDegrees( T a, T b ) Method to calculate the diference between angles correctly even if they wrap between -180 and 180. Parameters : a angle 1 in radians b angle 2 in radians Return : The minimum difference between the two angles","title":"function angleDiffDegrees"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-computeskewsymmetric3","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > computeSkewSymmetric3( const Eigen::Matrix< T, 3, 1 > & v ) Compute the 3x3 skew-symmetric matrix from a vector 3x1. Parameters : v A vector with 3 elements Return : A 3x3 skew-symmetric matrix","title":"function computeSkewSymmetric3"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-computeskewsymmetric2","text":"template <typename T > inline Eigen::Matrix< T, 2, 2 > computeSkewSymmetric2( T c ) Compute the 2x2 skew-symmetric matrix from a constant (int, float or double) Parameters : v A constant Return : A 2x2 skew-symmetric matrix","title":"function computeSkewSymmetric2"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-rotationangularbodytoinertial","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > rotationAngularBodyToInertial( const Eigen::Matrix< T, 3, 1 > & v ) Compute the rotation matrix that converts angular velocities expressed in the body frame to angular velocities expressed in the inertial frame (according to Z-Y-X convention) - makes use of small angle approximation. Parameters : v A vector with 3 elements (roll, pitch, yaw) Return : A 3x3 rotation matrix","title":"function rotationAngularBodyToInertial"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-rotationbodytoinertial","text":"template <typename T > inline Eigen::Matrix< T, 3, 3 > rotationBodyToInertial( const Eigen::Matrix< T, 3, 1 > & v ) Method that returns a rotation matrix from body frame to inertial frame, assuming a Z-Y-X convention. Parameters : v A vector with euler angles (roll, pith, yaw) according to Z-Y-X convention Return : A 3x3 rotation matrix","title":"function rotationBodyToInertial"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#function-spherical_to_cartesian","text":"template <typename T > Eigen::Matrix< T, 3, 1 > spherical_to_cartesian( T bearing, T elevation, T range ) Convert from spherical to cartesian coordinates. Used mainly with usbl fixes. Parameters : bearing Horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation Angle measured between the horizontal and the vehicle line of sight to the object range Distance to the object bearing Horizontal angle between the direction of an object and another object or between it and the true north direction in degrees. elevation Angle measured between the horizontal and the vehicle line of sight to the object range Distance to the object Return : Eigen Vector with cartesian coordinates Eigen Vector with cartesian coordinates Authors: Joao Quintas ( jquintas@gmail.com ) Joao Cruz ( joao.pedro.cruz@tecnico.ulisboa.pt ) Marcelo Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Maintained by: Marcelo Fialho Jacinto ( marcelo.jacinto@tecnico.ulisboa.pt ) Last Update: 14/12/2021 License: MIT File: spherical_coordinates.cpp Brief: Defines all functions related to spherical coordinates conversions","title":"function spherical_to_cartesian"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#variable-enu_ned_inertial_q","text":"static const Eigen::Quaternion< T > ENU_NED_INERTIAL_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, M_PI_2)); Static quaternion to convert a rotation expressed in ENU to a rotation expressed in NED (Z->Y->X convention) on the inertial frame Rotate PI/2 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. NOTE: this quaternion is as valid as the quaternion representing the rotation from NED to ENU (quaternion ambiguity) on the inertial frame","title":"variable ENU_NED_INERTIAL_Q"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#variable-enu_ned_body_q","text":"static const Eigen::Quaternion< T > ENU_NED_BODY_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, 0.0)); Static quaternion to convert a rotation expressed in ENU body frame (ROS base_link) to a rotation expressed in NED body frame (Z->Y->X convention) Rotate 0 about Z-axis -> Rotate 0 about Y-axis -> Rotate PI about X-axis. NOTE: this quaternion is as valid as the quaternion representing the rotation from NED to ENU (quaternion ambiguity) on the body frame","title":"variable ENU_NED_BODY_Q"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#variable-body_enu_ned_q","text":"static const Eigen::Quaternion< T > BODY_ENU_NED_Q = euler_to_quaternion(Eigen::Matrix<T, 3, 1>(M_PI, 0.0, 0.0)); Static quaternion needed for rotating vectors in body frames between ENU and NED +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU).","title":"variable BODY_ENU_NED_Q"},{"location":"api/markdown/dsor_utils/Namespaces/namespaceDSOR/#variable-body_enu_ned_tf","text":"static const Eigen::Transform< T, 3, Eigen::Affine > BODY_ENU_NED_TF = Eigen::Transform<T, 3, Eigen::Affine>(BODY_ENU_NED_Q<T>); Static affine matrix to roate vectors ENU (or NED) -> NED (or ENU) expressed in body frame +PI rotation around X (Forward) axis transforms from Forward, Right, Down (body frame in NED) Fto Forward, Left, Up (body frame in ENU). Updated on 2023-05-26 at 16:18:58 +0000","title":"variable BODY_ENU_NED_TF"},{"location":"api/markdown/dsor_utils/Namespaces/namespacetps/","text":"tps More... Functions Name template <typename T > constexpr T pow (T input, unsigned int power) Detailed Description Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Abstract class for moving filters. Moving filter are real time filter used for applications where continuous filtering is necessary as it can be part of an control system. Functions Documentation function pow template <typename T > constexpr T pow( T input, unsigned int power ) Updated on 2023-05-26 at 16:18:58 +0000","title":"tps"},{"location":"api/markdown/dsor_utils/Namespaces/namespacetps/#tps","text":"More...","title":"tps"},{"location":"api/markdown/dsor_utils/Namespaces/namespacetps/#functions","text":"Name template <typename T > constexpr T pow (T input, unsigned int power)","title":"Functions"},{"location":"api/markdown/dsor_utils/Namespaces/namespacetps/#detailed-description","text":"Authors: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Maintained by: Jimmy van den Berg ( vandenberg.jimmy@gmail.com ) Last Update: 08/02/2018 Github: https://github.com/jimmyberg/DigitalFilters License: GNU Brief: Abstract class for moving filters. Moving filter are real time filter used for applications where continuous filtering is necessary as it can be part of an control system.","title":"Detailed Description"},{"location":"api/markdown/dsor_utils/Namespaces/namespacetps/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/markdown/dsor_utils/Namespaces/namespacetps/#function-pow","text":"template <typename T > constexpr T pow( T input, unsigned int power ) Updated on 2023-05-26 at 16:18:58 +0000","title":"function pow"},{"location":"dsor-ros-messages/","text":"DSOR Messages","title":"Reference"},{"location":"dsor-utility-functions/","text":"Math TODO - create documentation for this API Rotations TODO - create documentation for this API Frames This library implements a set of templates to convert between ENU frame and NED frames, both for angles expressed in the inertial frame and in the body frame of a vehicle. Conventions on quaternion rotations between frames In ROS a quaternion expresses a rotation of the body frame of the vehicle (which is ENU, i.e. ENU_base_link) with respect to (w.r.t) the inertial frame of reference in ENU (i.e. ENU_inertial_frame). Note that in ENU_base_link, the X-axis comes out of the front of the vehicle and a Z-axis that goes \"out of the vehicle in upwards direction\". On the other hand, in marine and aerial vehicles it is typical to consider a body frame which is expressed in NED_base_link, where the X-axis also comes out of the front of the vehicle but the Z-axis goes \"out of the vehicle in downwards direction\", according to the following figure (adapted from PX4 website). Therefore, according to the literature, a quaternion should express a rotation of the body frame of the vehicle (which is NED, i.e. NED_base_link) with respect to (w.r.t) the inertial frame of reference in NED (i.e. NED_inertial_frame). From the Figure it is trivial to conclude that rotating ENU_base_link <-> NED_base_link is different then rotating ENU_inertial_frame <-> NED_inertial_frame. This comes from the fact that in the body frame, both ENU and NED conventions arbitrate that the X axis comes forwards of the vehicle (this axis does not change), while in the inertial frame you can see from the figure above that it does change. Now that we have explained both the rotations in the body and inertial frames, let's see how to perform them: Inertial Frame 1.1) To convert a rotation expressed in ENU to a rotation expressed in NED, we must apply the following rotation (using Z-Y-X convention): - Rotate 90\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate 180\u00ba about X-axis 1.2) To convert a rotation expressed in NED to a rotation expressed in ENU, we must apply the following rotation (using Z-Y-X convention): - Rotate -90\u00ba about Z-axis - Rotate 180\u00ba about Y-axis - Rotate 0\u00ba about X-axis Body Frame (a.k.a ROS base_link) 2.1) To convert a rotation expressed in the ENU body frame (ROS base_link) to a rotation expressed in NED body frame (the typical body frame adopted for aerial and marine crafts), we must apply the following rotation (using Z-Y-X convention): - Rotate 0\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate 180\u00ba about X-axis 2.2) To convert a rotation expressed in the NED body frame (the typical body frame adopted for aerial and marine crafts) to a rotation expressed in the ENU body frame (ROS base_link), we must apply the following rotation (using Z-Y-X convention): - Rotate 0\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate -180\u00ba about X-axis Given this knowledge, we can now convert a ROS quaternion/rotation expressed in ENU_inertial_frame w.r.t. ENU_base_link to a \"regular\" quaternion expressed in NED_inertial_frame w.r.t. NED_base_link. ROS -> \"regular\" - State: rotation in ENU w.r.t. ENU_base_link - Action: Apply body frame rotation (operation 2.1) - State: rotation in ENU w.r.t. NED_base_link - Action: Apply inertial frame rotation (operation 1.1) - State: rotation in NED w.r.t. NED_base_link \"regular\" -> ROS - State: rotation in NED w.r.t. NED_base_link - Action: Apply body frame rotation (operation 2.2) - State: rotation in NED w.r.t. ENU_base_link - Action: Apply inertial frame rotation (operation 1.2) - State: rotation in ENU w.r.t. ENU_base_link Transform vectors and covariances between frames For vectors w.r.t body or inertial frames expressed in ENU (Forward, Left, Up) , the transformation to express them in NED (Forward, Right, Down) depends on their respective frame of reference. To transform vectors w.r.t the body-frame the conversion is quite simple and only requires us to: - apply an 180\u00ba rotation around X (Forward) axis To transform vectors w.r.t the inertial-frame the conversion is different and is made in the following way: - Switch XY axis - Invert the Z axis Regarding coordinate frame conversion for covariance matrices, the principle is similar, however, the computations are slightly different as shown on the following image. Spherical Coordinates TODO - create documentation for this API","title":"Reference"},{"location":"dsor-utility-functions/#math","text":"TODO - create documentation for this API","title":"Math"},{"location":"dsor-utility-functions/#rotations","text":"TODO - create documentation for this API","title":"Rotations"},{"location":"dsor-utility-functions/#frames","text":"This library implements a set of templates to convert between ENU frame and NED frames, both for angles expressed in the inertial frame and in the body frame of a vehicle.","title":"Frames"},{"location":"dsor-utility-functions/#conventions-on-quaternion-rotations-between-frames","text":"In ROS a quaternion expresses a rotation of the body frame of the vehicle (which is ENU, i.e. ENU_base_link) with respect to (w.r.t) the inertial frame of reference in ENU (i.e. ENU_inertial_frame). Note that in ENU_base_link, the X-axis comes out of the front of the vehicle and a Z-axis that goes \"out of the vehicle in upwards direction\". On the other hand, in marine and aerial vehicles it is typical to consider a body frame which is expressed in NED_base_link, where the X-axis also comes out of the front of the vehicle but the Z-axis goes \"out of the vehicle in downwards direction\", according to the following figure (adapted from PX4 website). Therefore, according to the literature, a quaternion should express a rotation of the body frame of the vehicle (which is NED, i.e. NED_base_link) with respect to (w.r.t) the inertial frame of reference in NED (i.e. NED_inertial_frame). From the Figure it is trivial to conclude that rotating ENU_base_link <-> NED_base_link is different then rotating ENU_inertial_frame <-> NED_inertial_frame. This comes from the fact that in the body frame, both ENU and NED conventions arbitrate that the X axis comes forwards of the vehicle (this axis does not change), while in the inertial frame you can see from the figure above that it does change. Now that we have explained both the rotations in the body and inertial frames, let's see how to perform them: Inertial Frame 1.1) To convert a rotation expressed in ENU to a rotation expressed in NED, we must apply the following rotation (using Z-Y-X convention): - Rotate 90\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate 180\u00ba about X-axis 1.2) To convert a rotation expressed in NED to a rotation expressed in ENU, we must apply the following rotation (using Z-Y-X convention): - Rotate -90\u00ba about Z-axis - Rotate 180\u00ba about Y-axis - Rotate 0\u00ba about X-axis Body Frame (a.k.a ROS base_link) 2.1) To convert a rotation expressed in the ENU body frame (ROS base_link) to a rotation expressed in NED body frame (the typical body frame adopted for aerial and marine crafts), we must apply the following rotation (using Z-Y-X convention): - Rotate 0\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate 180\u00ba about X-axis 2.2) To convert a rotation expressed in the NED body frame (the typical body frame adopted for aerial and marine crafts) to a rotation expressed in the ENU body frame (ROS base_link), we must apply the following rotation (using Z-Y-X convention): - Rotate 0\u00ba about Z-axis - Rotate 0\u00ba about Y-axis - Rotate -180\u00ba about X-axis Given this knowledge, we can now convert a ROS quaternion/rotation expressed in ENU_inertial_frame w.r.t. ENU_base_link to a \"regular\" quaternion expressed in NED_inertial_frame w.r.t. NED_base_link. ROS -> \"regular\" - State: rotation in ENU w.r.t. ENU_base_link - Action: Apply body frame rotation (operation 2.1) - State: rotation in ENU w.r.t. NED_base_link - Action: Apply inertial frame rotation (operation 1.1) - State: rotation in NED w.r.t. NED_base_link \"regular\" -> ROS - State: rotation in NED w.r.t. NED_base_link - Action: Apply body frame rotation (operation 2.2) - State: rotation in NED w.r.t. ENU_base_link - Action: Apply inertial frame rotation (operation 1.2) - State: rotation in ENU w.r.t. ENU_base_link","title":"Conventions on quaternion rotations between frames"},{"location":"dsor-utility-functions/#transform-vectors-and-covariances-between-frames","text":"For vectors w.r.t body or inertial frames expressed in ENU (Forward, Left, Up) , the transformation to express them in NED (Forward, Right, Down) depends on their respective frame of reference. To transform vectors w.r.t the body-frame the conversion is quite simple and only requires us to: - apply an 180\u00ba rotation around X (Forward) axis To transform vectors w.r.t the inertial-frame the conversion is different and is made in the following way: - Switch XY axis - Invert the Z axis Regarding coordinate frame conversion for covariance matrices, the principle is similar, however, the computations are slightly different as shown on the following image.","title":"Transform vectors and covariances between frames"},{"location":"dsor-utility-functions/#spherical-coordinates","text":"TODO - create documentation for this API","title":"Spherical Coordinates"},{"location":"pages/Acknowledgments/","text":"The DSOR Utils project results from the work and dedication of many. Share the love \u2764\ufe0f with the following members that came before you did! Active Developers Marcelo Jacinto marcelo.jacinto@tecnico.ulisboa.pt Andr\u00e9 Potes andre.potes@tecnico.ulisboa.pt And never forget, we stand on the shoulders of giants!","title":"Acknowledgments"},{"location":"pages/Acknowledgments/#active-developers","text":"Marcelo Jacinto marcelo.jacinto@tecnico.ulisboa.pt Andr\u00e9 Potes andre.potes@tecnico.ulisboa.pt And never forget, we stand on the shoulders of giants!","title":"Active Developers"},{"location":"pages/CHANGELOG/","text":"Changelog v1.1 First version of dsor_utils repository with automatic documentation generation","title":"Changelog"},{"location":"pages/CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"pages/CHANGELOG/#v11","text":"First version of dsor_utils repository with automatic documentation generation","title":"v1.1"},{"location":"pages/CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at marcelo.jacinto@tecnico.ulisboa.pt. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"pages/CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"pages/CODE_OF_CONDUCT/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"pages/CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"pages/CODE_OF_CONDUCT/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"pages/CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"pages/CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at marcelo.jacinto@tecnico.ulisboa.pt. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"pages/CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"pages/CONTRIBUTING/","text":"TODO","title":"Contributing"},{"location":"pages/CONTRIBUTING/#todo","text":"","title":"TODO"},{"location":"pages/LICENSE/","text":"MIT License Copyright (c) 2021 dsor-isr Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"pages/get_started/Get-Started/","text":"TODO","title":"Get Started"}]}